import _ from "node:path";
import { ESLintUtils as ue, ASTUtils as W } from "@typescript-eslint/utils";
import { minimatch as D } from "minimatch";
import ce from "natural-compare-lite";
import { builtinModules as de } from "node:module";
let j = ue.RuleCreator(
  (r) => `https://eslint-plugin-perfectionist.azat.io/rules/${r}`
), x = (r, l) => {
  for (let s = 0, t = r.length; s < t; s++) {
    let u = r[s];
    if (l.group === u || Array.isArray(u) && typeof l.group == "string" && u.includes(l.group))
      return s;
  }
  return r.length;
}, v = (r) => {
  let [l, s] = r;
  return s - l;
}, k = (r) => r > 0;
var p = /* @__PURE__ */ ((r) => (r.alphabetical = "alphabetical", r["line-length"] = "line-length", r.natural = "natural", r))(p || {}), d = /* @__PURE__ */ ((r) => (r.desc = "desc", r.asc = "asc", r))(d || {});
let R = (r) => {
  let l, s = (u) => {
    !l && r.flat().includes(u) && (l = u);
  };
  return {
    getGroup: () => l ?? "unknown",
    setCustomGroups: (u, n) => {
      if (u)
        for (let [e, a] of Object.entries(u))
          Array.isArray(a) && a.some(
            (i) => D(n, i, {
              nocomment: !0
            })
          ) && s(e), typeof a == "string" && D(n, a, {
            nocomment: !0
          }) && s(e);
    },
    defineGroup: s
  };
}, O = (r, l, s) => {
  var e, a;
  if ((e = l.dependencies) != null && e.includes(r.name))
    return -1;
  if ((a = r.dependencies) != null && a.includes(l.name))
    return 1;
  let t = s.order === "asc" ? 1 : -1, u, n = (i) => s["ignore-case"] ? i.toLowerCase() : i;
  return s.type === p.alphabetical ? u = (i, o) => n(i.name).localeCompare(n(o.name)) : s.type === p.natural ? u = (i, o) => ce(n(i.name), n(o.name)) : u = (i, o) => {
    let c = i.size, y = o.size, h = s["max-line-length"];
    if (h) {
      let f = (g, m) => g > h && m.hasMultipleImportDeclarations;
      f(c, i) && (c = i.name.length + 10), f(y, o) && (y = o.name.length + 10);
    }
    return c - y;
  }, t * u(r, l);
}, A = (r, l) => [...r].sort((s, t) => O(s, t, l)), fe = (r, l) => {
  let s = l.getTokenAfter(r, {
    filter: ({ value: t, type: u }) => !(u === "Punctuator" && [",", ";"].includes(t)),
    includeComments: !0
  });
  return ((s == null ? void 0 : s.type) === "Block" || (s == null ? void 0 : s.type) === "Line") && r.loc.end.line === s.loc.end.line ? s : null;
}, pe = (r, l) => Array.isArray(r) && r.some(
  (s) => D(l.trim(), s, {
    nocomment: !0
  })
) || typeof r == "string" && D(l.trim(), r, {
  nocomment: !0
}) || r === !0, J = (r, l) => {
  let [s, t] = l.getTokensBefore(r, {
    filter: ({ value: u, type: n }) => !(n === "Punctuator" && [",", ";"].includes(u)),
    includeComments: !0,
    count: 2
  });
  return ((t == null ? void 0 : t.type) === "Block" || (t == null ? void 0 : t.type) === "Line") && r.loc.start.line - t.loc.end.line <= 1 && (s == null ? void 0 : s.loc.end.line) !== t.loc.start.line ? t : null;
}, M = (r, l, s) => {
  var a;
  let t = r.range.at(0), u = r.range.at(1), n = l.text.slice(t, u);
  if (W.isParenthesized(r, l)) {
    let i = l.getTokenBefore(
      r,
      W.isOpeningParenToken
    ), o = l.getTokenAfter(
      r,
      W.isClosingParenToken
    );
    t = i.range.at(0), u = o.range.at(1);
  }
  let e = J(r, l);
  if (n.endsWith(";") || n.endsWith(",")) {
    let i = l.getTokensAfter(r, {
      includeComments: !0,
      count: 2
    });
    r.loc.start.line === ((a = i.at(1)) == null ? void 0 : a.loc.start.line) && (u -= 1);
  }
  return e && !pe(
    (s == null ? void 0 : s.partitionComment) ?? !1,
    e.value
  ) && (t = e.range.at(0)), [t, u];
}, T = (r, l, s, t, u) => {
  var a, i;
  let n = [], e = ((a = l.at(0)) == null ? void 0 : a.node.loc.start.line) === ((i = l.at(-1)) == null ? void 0 : i.node.loc.end.line);
  for (let o = 0, c = l.length; o < c; o++) {
    let { node: y } = l.at(o);
    n.push(
      r.replaceTextRange(
        M(y, t, u),
        t.text.slice(
          ...M(s.at(o).node, t, u)
        )
      )
    );
    let h = fe(s.at(o).node, t);
    if (h && !e) {
      let g = [
        t.getTokenBefore(h).range.at(1),
        h.range.at(1)
      ];
      n.push(r.replaceTextRange(g, ""));
      let m = t.getTokenAfter(y);
      n.push(
        r.insertTextAfter(
          (m == null ? void 0 : m.loc.end.line) === y.loc.end.line ? m : y,
          t.text.slice(...g)
        )
      );
    }
  }
  return n;
}, C = (r = {}, l) => Object.assign(l, r), P = (r, l) => {
  if (r.length > 1)
    for (let s = 1; s < r.length; s++) {
      let t = r.at(s - 1), u = r.at(s);
      t && u && l(t, u, s - 1);
    }
};
const X = "sort-svelte-attributes", ge = j({
  name: X,
  meta: {
    type: "suggestion",
    docs: {
      description: "enforce sorted Svelte attributes"
    },
    fixable: "code",
    schema: [
      {
        type: "object",
        properties: {
          "custom-groups": {
            type: "object"
          },
          type: {
            enum: [
              p.alphabetical,
              p.natural,
              p["line-length"]
            ],
            default: p.alphabetical,
            type: "string"
          },
          order: {
            enum: [d.asc, d.desc],
            default: d.asc,
            type: "string"
          },
          "ignore-case": {
            type: "boolean",
            default: !1
          },
          groups: {
            type: "array"
          }
        },
        additionalProperties: !1
      }
    ],
    messages: {
      unexpectedSvelteAttributesOrder: 'Expected "{{right}}" to come before "{{left}}"'
    }
  },
  defaultOptions: [
    {
      type: p.alphabetical,
      order: d.asc
    }
  ],
  create: (r) => _.extname(r.getFilename()) !== ".svelte" ? {} : {
    SvelteStartTag: (l) => {
      if (l.attributes.length > 1) {
        let s = C(r.options.at(0), {
          type: p.alphabetical,
          order: d.asc,
          "ignore-case": !1,
          "custom-groups": {},
          groups: []
        }), t = r.getSourceCode(), u = l.attributes.reduce(
          (n, e) => {
            if (e.type === "SvelteSpreadAttribute")
              return n.push([]), n;
            let a, { getGroup: i, defineGroup: o, setCustomGroups: c } = R(
              s.groups
            );
            return e.key.type === "SvelteSpecialDirectiveKey" ? a = t.text.slice(...e.key.range) : typeof e.key.name == "string" ? { name: a } = e.key : a = t.text.slice(...e.key.range), c(s["custom-groups"], a), e.type === "SvelteShorthandAttribute" && (o("svelte-shorthand"), o("shorthand")), (!("value" in e) || Array.isArray(e.value) && !e.value.at(0)) && o("shorthand"), e.loc.start.line !== e.loc.end.line && o("multiline"), n.at(-1).push({
              size: v(e.range),
              node: e,
              group: i(),
              name: a
            }), n;
          },
          [[]]
        );
        for (let n of u)
          P(n, (e, a) => {
            let i = x(s.groups, e), o = x(s.groups, a);
            (i > o || i === o && k(O(e, a, s))) && r.report({
              messageId: "unexpectedSvelteAttributesOrder",
              data: {
                left: e.name,
                right: a.name
              },
              node: a.node,
              fix: (c) => {
                let y = {};
                for (let f of n) {
                  let g = x(s.groups, f);
                  g in y ? y[g] = A(
                    [...y[g], f],
                    s
                  ) : y[g] = [f];
                }
                let h = [];
                for (let f of Object.keys(y).sort())
                  h.push(...A(y[f], s));
                return T(c, n, h, t);
              }
            });
          });
      }
    }
  }
}), q = "sort-astro-attributes", ye = j({
  name: q,
  meta: {
    type: "suggestion",
    docs: {
      description: "enforce sorted Astro attributes"
    },
    fixable: "code",
    schema: [
      {
        type: "object",
        properties: {
          "custom-groups": {
            type: "object"
          },
          type: {
            enum: [
              p.alphabetical,
              p.natural,
              p["line-length"]
            ],
            default: p.alphabetical,
            type: "string"
          },
          order: {
            enum: [d.asc, d.desc],
            default: d.asc,
            type: "string"
          },
          "ignore-case": {
            type: "boolean",
            default: !1
          },
          groups: {
            type: "array"
          }
        },
        additionalProperties: !1
      }
    ],
    messages: {
      unexpectedAstroAttributesOrder: 'Expected "{{right}}" to come before "{{left}}"'
    }
  },
  defaultOptions: [
    {
      type: p.alphabetical,
      order: d.asc
    }
  ],
  // @ts-ignore
  create: (r) => _.extname(r.getFilename()) !== ".astro" ? {} : {
    JSXElement: (l) => {
      let { attributes: s } = l.openingElement;
      if (s.length > 1) {
        let t = C(r.options.at(0), {
          type: p.alphabetical,
          order: d.asc,
          "ignore-case": !1,
          "custom-groups": {},
          groups: []
        }), u = r.getSourceCode(), n = s.reduce(
          (e, a) => {
            if (a.type === "JSXSpreadAttribute")
              return e.push([]), e;
            let i = typeof a.name.name == "string" ? a.name.name : u.text.slice(...a.name.range), { getGroup: o, defineGroup: c, setCustomGroups: y } = R(
              t.groups
            );
            return y(t["custom-groups"], i), a.type === "AstroShorthandAttribute" && (c("astro-shorthand"), c("shorthand")), a.value === null && c("shorthand"), a.loc.start.line !== a.loc.end.line && c("multiline"), e.at(-1).push({
              size: v(a.range),
              node: a,
              group: o(),
              name: i
            }), e;
          },
          [[]]
        );
        for (let e of n)
          P(e, (a, i) => {
            let o = x(t.groups, a), c = x(t.groups, i);
            (o > c || o === c && k(O(a, i, t))) && r.report({
              messageId: "unexpectedAstroAttributesOrder",
              data: {
                left: a.name,
                right: i.name
              },
              node: i.node,
              fix: (y) => {
                let h = {};
                for (let g of e) {
                  let m = x(t.groups, g);
                  m in h ? h[m] = A(
                    [...h[m], g],
                    t
                  ) : h[m] = [g];
                }
                let f = [];
                for (let g of Object.keys(h).sort())
                  f.push(...A(h[g], t));
                return T(y, e, f, u);
              }
            });
          });
      }
    }
  }
});
let I = (r) => r.replaceAll(/\s\s+/g, " ").trim();
const K = "sort-array-includes", me = j({
  name: K,
  meta: {
    type: "suggestion",
    docs: {
      description: "enforce sorted arrays before include method"
    },
    fixable: "code",
    schema: [
      {
        type: "object",
        properties: {
          type: {
            enum: [
              p.alphabetical,
              p.natural,
              p["line-length"]
            ],
            default: p.alphabetical,
            type: "string"
          },
          order: {
            enum: [d.asc, d.desc],
            default: d.asc,
            type: "string"
          },
          "ignore-case": {
            type: "boolean",
            default: !1
          },
          "spread-last": {
            type: "boolean",
            default: !1
          }
        },
        additionalProperties: !1
      }
    ],
    messages: {
      unexpectedArrayIncludesOrder: 'Expected "{{right}}" to come before "{{left}}"'
    }
  },
  defaultOptions: [
    {
      type: p.alphabetical,
      order: d.asc
    }
  ],
  create: (r) => ({
    MemberExpression: (l) => {
      if ((l.object.type === "ArrayExpression" || l.object.type === "NewExpression") && l.property.type === "Identifier" && l.property.name === "includes") {
        let s = l.object.type === "ArrayExpression" ? l.object.elements : l.object.arguments;
        if (s.length > 1) {
          let t = C(r.options.at(0), {
            type: p.alphabetical,
            order: d.asc,
            "ignore-case": !1,
            "spread-last": !1
          }), u = r.getSourceCode(), n = s.reduce(
            (e, a) => (a !== null && e.at(0).push({
              name: a.type === "Literal" ? `${a.value}` : u.text.slice(...a.range),
              size: v(a.range),
              type: a.type,
              node: a
            }), e),
            [[], []]
          ).flat();
          P(n, (e, a) => {
            let i;
            t["spread-last"] && e.node.type === "Literal" && a.node.type === "SpreadElement" ? i = !1 : t["spread-last"] && e.node.type === "SpreadElement" && a.node.type === "Literal" ? i = !0 : i = k(O(e, a, t)), i && r.report({
              messageId: "unexpectedArrayIncludesOrder",
              data: {
                left: I(e.name),
                right: I(a.name)
              },
              node: a.node,
              fix: (o) => {
                let c = A(n, t);
                if (t["spread-last"])
                  for (let y = 0, h = c.length; y < h; y++)
                    c.at(y).node.type === "SpreadElement" && c.push(c.splice(y, 1).at(0));
                return T(o, n, c, u);
              }
            });
          });
        }
      }
    }
  })
}), F = "sort-vue-attributes", he = j({
  name: F,
  meta: {
    type: "suggestion",
    docs: {
      description: "enforce sorted Vue attributes"
    },
    fixable: "code",
    schema: [
      {
        type: "object",
        properties: {
          "custom-groups": {
            type: "object"
          },
          type: {
            enum: [
              p.alphabetical,
              p.natural,
              p["line-length"]
            ],
            default: p.alphabetical,
            type: "string"
          },
          order: {
            enum: [d.asc, d.desc],
            default: d.asc,
            type: "string"
          },
          "ignore-case": {
            type: "boolean",
            default: !1
          },
          groups: {
            type: "array",
            default: []
          }
        },
        additionalProperties: !1
      }
    ],
    messages: {
      unexpectedVueAttributesOrder: 'Expected "{{right}}" to come before "{{left}}"'
    }
  },
  defaultOptions: [
    {
      type: p.alphabetical,
      order: d.asc
    }
  ],
  create: (r) => {
    if (_.extname(r.getFilename()) !== ".vue")
      return {};
    if (!("defineTemplateBodyVisitor" in r.parserServices))
      return {};
    let { defineTemplateBodyVisitor: l } = r.parserServices;
    return l({
      VStartTag: (s) => {
        if (s.attributes.length > 1) {
          let t = C(r.options.at(0), {
            type: p.alphabetical,
            order: d.asc,
            "ignore-case": !1,
            "custom-groups": {},
            groups: []
          }), u = r.getSourceCode(), n = s.attributes.reduce(
            (e, a) => {
              if (a.key.type === "VDirectiveKey" && a.key.name.rawName === "bind")
                return e.push([]), e;
              let i, { getGroup: o, defineGroup: c, setCustomGroups: y } = R(
                t.groups
              );
              return typeof a.key.name == "string" && a.key.type !== "VDirectiveKey" ? i = a.key.rawName : i = u.text.slice(...a.key.range), y(t["custom-groups"], i), a.value === null && c("shorthand"), a.loc.start.line !== a.loc.end.line && c("multiline"), e.at(-1).push({
                size: v(a.range),
                node: a,
                group: o(),
                name: i
              }), e;
            },
            [[]]
          );
          for (let e of n)
            P(e, (a, i) => {
              let o = x(t.groups, a), c = x(t.groups, i);
              (o > c || o === c && k(O(a, i, t))) && r.report({
                messageId: "unexpectedVueAttributesOrder",
                data: {
                  left: a.name,
                  right: i.name
                },
                node: i.node,
                fix: (y) => {
                  let h = {};
                  for (let g of e) {
                    let m = x(t.groups, g);
                    m in h ? h[m] = A(
                      [...h[m], g],
                      t
                    ) : h[m] = [g];
                  }
                  let f = [];
                  for (let g of Object.keys(h).sort())
                    f.push(...A(h[g], t));
                  return T(y, e, f, u);
                }
              });
            });
        }
      }
    });
  }
}), H = "sort-named-exports", be = j({
  name: H,
  meta: {
    type: "suggestion",
    docs: {
      description: "enforce sorted named exports"
    },
    fixable: "code",
    schema: [
      {
        type: "object",
        properties: {
          type: {
            enum: [
              p.alphabetical,
              p.natural,
              p["line-length"]
            ],
            default: p.alphabetical,
            type: "string"
          },
          order: {
            enum: [d.asc, d.desc],
            default: d.asc,
            type: "string"
          },
          "ignore-case": {
            type: "boolean",
            default: !1
          }
        },
        additionalProperties: !1
      }
    ],
    messages: {
      unexpectedNamedExportsOrder: 'Expected "{{right}}" to come before "{{left}}"'
    }
  },
  defaultOptions: [
    {
      type: p.alphabetical,
      order: d.asc
    }
  ],
  create: (r) => ({
    ExportNamedDeclaration: (l) => {
      if (l.specifiers.length > 1) {
        let s = C(r.options.at(0), {
          type: p.alphabetical,
          "ignore-case": !1,
          order: d.asc
        }), t = r.getSourceCode(), u = l.specifiers.map((n) => ({
          size: v(n.range),
          name: n.local.name,
          node: n
        }));
        P(u, (n, e) => {
          k(O(n, e, s)) && r.report({
            messageId: "unexpectedNamedExportsOrder",
            data: {
              left: n.name,
              right: e.name
            },
            node: e.node,
            fix: (a) => T(a, u, A(u, s), t)
          });
        });
      }
    }
  })
}), Q = "sort-named-imports", xe = j({
  name: Q,
  meta: {
    type: "suggestion",
    docs: {
      description: "enforce sorted named imports"
    },
    fixable: "code",
    schema: [
      {
        type: "object",
        properties: {
          type: {
            enum: [
              p.alphabetical,
              p.natural,
              p["line-length"]
            ],
            default: p.alphabetical,
            type: "string"
          },
          order: {
            enum: [d.asc, d.desc],
            default: d.asc,
            type: "string"
          },
          "ignore-case": {
            type: "boolean",
            default: !1
          },
          "ignore-alias": {
            type: "boolean",
            default: !1
          }
        },
        additionalProperties: !1
      }
    ],
    messages: {
      unexpectedNamedImportsOrder: 'Expected "{{right}}" to come before "{{left}}"'
    }
  },
  defaultOptions: [
    {
      type: p.alphabetical,
      order: d.asc
    }
  ],
  create: (r) => ({
    ImportDeclaration: (l) => {
      let s = l.specifiers.filter(
        ({ type: t }) => t === "ImportSpecifier"
      );
      if (s.length > 1) {
        let t = C(r.options.at(0), {
          type: p.alphabetical,
          "ignore-alias": !0,
          "ignore-case": !1,
          order: d.asc
        }), u = r.getSourceCode(), n = s.map((e) => {
          let { name: a } = e.local;
          return t["ignore-alias"] && e.type === "ImportSpecifier" && ({ name: a } = e.imported), {
            size: v(e.range),
            node: e,
            name: a
          };
        });
        P(n, (e, a) => {
          k(O(e, a, t)) && r.report({
            messageId: "unexpectedNamedImportsOrder",
            data: {
              left: e.name,
              right: a.name
            },
            node: a.node,
            fix: (i) => T(i, n, A(n, t), u)
          });
        });
      }
    }
  })
});
let B = (r, l, s) => r.lines.slice(
  l.node.loc.end.line,
  s.node.loc.start.line - 1
).filter((u) => !u.trim().length).length;
const Y = "sort-object-types", Ee = j({
  name: Y,
  meta: {
    type: "suggestion",
    docs: {
      description: "enforce sorted object types"
    },
    fixable: "code",
    schema: [
      {
        type: "object",
        properties: {
          "custom-groups": {
            type: "object"
          },
          type: {
            enum: [
              p.alphabetical,
              p.natural,
              p["line-length"]
            ],
            default: p.alphabetical,
            type: "string"
          },
          order: {
            enum: [d.asc, d.desc],
            default: d.asc,
            type: "string"
          },
          "ignore-case": {
            type: "boolean",
            default: !1
          },
          groups: {
            type: "array",
            default: []
          },
          "partition-by-new-line": {
            type: "boolean",
            default: !1
          }
        },
        additionalProperties: !1
      }
    ],
    messages: {
      unexpectedObjectTypesOrder: 'Expected "{{right}}" to come before "{{left}}"'
    }
  },
  defaultOptions: [
    {
      type: p.alphabetical,
      order: d.asc
    }
  ],
  create: (r) => ({
    TSTypeLiteral: (l) => {
      if (l.members.length > 1) {
        let s = C(r.options.at(0), {
          "partition-by-new-line": !1,
          type: p.alphabetical,
          "ignore-case": !1,
          order: d.asc,
          "custom-groups": {},
          groups: []
        }), t = r.getSourceCode(), u = l.members.reduce(
          (n, e) => {
            var E, b, N, S;
            let a, i = t.text.slice(e.range.at(0), e.range.at(1)), o = (E = n.at(-1)) == null ? void 0 : E.at(-1), { getGroup: c, defineGroup: y, setCustomGroups: h } = R(
              s.groups
            ), f = (L) => L.replace(/(,|;)$/, "");
            if (e.type === "TSPropertySignature")
              e.key.type === "Identifier" ? { name: a } = e.key : e.key.type === "Literal" ? a = `${e.key.value}` : a = t.text.slice(
                e.range.at(0),
                (b = e.typeAnnotation) == null ? void 0 : b.range.at(0)
              );
            else if (e.type === "TSIndexSignature") {
              let L = ((N = e.typeAnnotation) == null ? void 0 : N.range.at(0)) ?? e.range.at(1);
              a = f(t.text.slice(e.range.at(0), L));
            } else
              a = f(
                t.text.slice(e.range.at(0), e.range.at(1))
              );
            h(s["custom-groups"], a), e.loc.start.line !== e.loc.end.line && y("multiline");
            let m = i.endsWith(";") || i.endsWith(",") ? 1 : 0, w = {
              size: v(e.range) - m,
              node: e,
              name: a
            };
            return s["partition-by-new-line"] && o && B(t, o, w) && n.push([]), (S = n.at(-1)) == null || S.push({
              ...w,
              group: c()
            }), n;
          },
          [[]]
        );
        for (let n of u)
          P(n, (e, a) => {
            let i = x(s.groups, e), o = x(s.groups, a);
            (i > o || i === o && k(O(e, a, s))) && r.report({
              messageId: "unexpectedObjectTypesOrder",
              data: {
                left: I(e.name),
                right: I(a.name)
              },
              node: a.node,
              fix: (c) => {
                let y = {};
                for (let f of n) {
                  let g = x(s.groups, f);
                  g in y ? y[g] = A(
                    [...y[g], f],
                    s
                  ) : y[g] = [f];
                }
                let h = [];
                for (let f of Object.keys(y).sort())
                  h.push(...A(y[f], s));
                return T(c, n, h, t);
              }
            });
          });
      }
    }
  })
}), Z = "sort-union-types", Se = j({
  name: Z,
  meta: {
    type: "suggestion",
    docs: {
      description: "enforce sorted union types"
    },
    fixable: "code",
    schema: [
      {
        type: "object",
        properties: {
          type: {
            enum: [
              p.alphabetical,
              p.natural,
              p["line-length"]
            ],
            default: p.alphabetical,
            type: "string"
          },
          order: {
            enum: [d.asc, d.desc],
            default: d.asc,
            type: "string"
          },
          "ignore-case": {
            type: "boolean",
            default: !1
          },
          "nullable-last": {
            type: "boolean",
            default: !1
          }
        },
        additionalProperties: !1
      }
    ],
    messages: {
      unexpectedUnionTypesOrder: 'Expected "{{right}}" to come before "{{left}}"'
    }
  },
  defaultOptions: [
    {
      type: p.alphabetical,
      order: d.asc
    }
  ],
  create: (r) => ({
    TSUnionType: (l) => {
      let s = r.getSourceCode(), t = C(r.options.at(0), {
        type: p.alphabetical,
        "nullable-last": !1,
        "ignore-case": !1,
        order: d.asc
      }), u = l.types.map((n) => ({
        group: n.type === "TSNullKeyword" || n.type === "TSUndefinedKeyword" ? "nullable" : "unknown",
        name: s.text.slice(...n.range),
        size: v(n.range),
        node: n
      }));
      P(u, (n, e) => {
        let a = k(O(n, e, t));
        t["nullable-last"] && (n.group === "nullable" && e.group === "unknown" ? a = !0 : n.group === "unknown" && e.group === "nullable" && (a = !1)), a && r.report({
          messageId: "unexpectedUnionTypesOrder",
          data: {
            left: I(n.name),
            right: I(e.name)
          },
          node: e.node,
          fix: (i) => {
            let o = [];
            if (t["nullable-last"]) {
              let c = [], y = u.filter((h) => h.group === "nullable" ? (c.push(h), !1) : !0);
              o = [
                ...A(y, t),
                ...A(c, t)
              ];
            } else
              o = A(u, t);
            return T(i, u, o, s);
          }
        });
      });
    }
  })
}), ee = "sort-interfaces", we = j({
  name: ee,
  meta: {
    type: "suggestion",
    docs: {
      description: "enforce sorted interface properties"
    },
    fixable: "code",
    schema: [
      {
        type: "object",
        properties: {
          "custom-groups": {
            type: "object"
          },
          type: {
            enum: [
              p.alphabetical,
              p.natural,
              p["line-length"]
            ],
            default: p.alphabetical,
            type: "string"
          },
          order: {
            enum: [d.asc, d.desc],
            default: d.asc,
            type: "string"
          },
          "ignore-case": {
            type: "boolean",
            default: !1
          },
          "ignore-pattern": {
            items: {
              type: "string"
            },
            type: "array"
          },
          groups: {
            type: "array",
            default: []
          },
          "partition-by-new-line": {
            type: "boolean",
            default: !1
          }
        },
        additionalProperties: !1
      }
    ],
    messages: {
      unexpectedInterfacePropertiesOrder: 'Expected "{{right}}" to come before "{{left}}"'
    }
  },
  defaultOptions: [
    {
      type: p.alphabetical,
      order: d.asc
    }
  ],
  create: (r) => ({
    TSInterfaceDeclaration: (l) => {
      if (l.body.body.length > 1) {
        let s = C(r.options.at(0), {
          "partition-by-new-line": !1,
          type: p.alphabetical,
          "ignore-case": !1,
          order: d.asc,
          "ignore-pattern": [],
          "custom-groups": {},
          groups: []
        });
        if (!s["ignore-pattern"].some(
          (t) => D(l.id.name, t, {
            nocomment: !0
          })
        )) {
          let t = r.getSourceCode(), u = l.body.body.reduce(
            (n, e) => {
              var f, g, m, w;
              if (e.type === "TSCallSignatureDeclaration")
                return n.push([]), n;
              let a = (f = n.at(-1)) == null ? void 0 : f.at(-1), i, { getGroup: o, defineGroup: c, setCustomGroups: y } = R(
                s.groups
              );
              if (e.type === "TSPropertySignature")
                if (e.key.type === "Identifier")
                  ({ name: i } = e.key);
                else if (e.key.type === "Literal")
                  i = `${e.key.value}`;
                else {
                  let E = ((g = e.typeAnnotation) == null ? void 0 : g.range.at(0)) ?? e.range.at(1) - (e.optional ? 1 : 0);
                  i = t.text.slice(e.range.at(0), E);
                }
              else if (e.type === "TSIndexSignature") {
                let E = ((m = e.typeAnnotation) == null ? void 0 : m.range.at(0)) ?? e.range.at(1);
                i = t.text.slice(e.range.at(0), E);
              } else {
                let E = ((w = e.returnType) == null ? void 0 : w.range.at(0)) ?? e.range.at(1);
                i = t.text.slice(e.range.at(0), E);
              }
              let h = {
                size: v(e.range),
                node: e,
                name: i
              };
              return s["partition-by-new-line"] && a && B(t, a, h) && n.push([]), y(s["custom-groups"], i), e.loc.start.line !== e.loc.end.line && c("multiline"), n.at(-1).push({
                ...h,
                group: o()
              }), n;
            },
            [[]]
          );
          for (let n of u)
            P(n, (e, a) => {
              let i = x(s.groups, e), o = x(s.groups, a);
              (i > o || i === o && k(O(e, a, s))) && r.report({
                messageId: "unexpectedInterfacePropertiesOrder",
                data: {
                  left: I(e.name),
                  right: I(a.name)
                },
                node: a.node,
                fix: (c) => {
                  let y = {};
                  for (let f of n) {
                    let g = x(s.groups, f);
                    g in y ? y[g] = A(
                      [...y[g], f],
                      s
                    ) : y[g] = [f];
                  }
                  let h = [];
                  for (let f of Object.keys(y).sort())
                    h.push(...A(y[f], s));
                  return T(c, n, h, t);
                }
              });
            });
        }
      }
    }
  })
}), te = "sort-jsx-props", Ae = j({
  name: te,
  meta: {
    type: "suggestion",
    docs: {
      description: "enforce sorted JSX props"
    },
    fixable: "code",
    schema: [
      {
        type: "object",
        properties: {
          "custom-groups": {
            type: "object"
          },
          type: {
            enum: [
              p.alphabetical,
              p.natural,
              p["line-length"]
            ],
            default: p.alphabetical,
            type: "string"
          },
          order: {
            enum: [d.asc, d.desc],
            default: d.asc,
            type: "string"
          },
          groups: {
            type: "array"
          },
          "ignore-case": {
            type: "boolean",
            default: !1
          }
        },
        additionalProperties: !1
      }
    ],
    messages: {
      unexpectedJSXPropsOrder: 'Expected "{{right}}" to come before "{{left}}"'
    }
  },
  defaultOptions: [
    {
      type: p.alphabetical,
      order: d.asc
    }
  ],
  create: (r) => [".svelte", ".astro", ".vue"].includes(
    _.extname(r.getFilename())
  ) ? {} : {
    JSXElement: (l) => {
      if (l.openingElement.attributes.length > 1) {
        let s = C(r.options.at(0), {
          type: p.alphabetical,
          "ignore-case": !1,
          order: d.asc,
          "custom-groups": {},
          groups: []
        }), t = r.getSourceCode(), u = l.openingElement.attributes.reduce(
          (n, e) => {
            if (e.type === "JSXSpreadAttribute")
              return n.push([]), n;
            let a = e.name.type === "JSXNamespacedName" ? `${e.name.namespace.name}:${e.name.name.name}` : e.name.name, { getGroup: i, defineGroup: o, setCustomGroups: c } = R(
              s.groups
            );
            c(s["custom-groups"], a), e.value === null && o("shorthand"), e.loc.start.line !== e.loc.end.line && o("multiline");
            let y = {
              size: v(e.range),
              group: i(),
              node: e,
              name: a
            };
            return n.at(-1).push(y), n;
          },
          [[]]
        );
        for (let n of u)
          P(n, (e, a) => {
            let i = x(s.groups, e), o = x(s.groups, a);
            (i > o || i === o && k(O(e, a, s))) && r.report({
              messageId: "unexpectedJSXPropsOrder",
              data: {
                left: e.name,
                right: a.name
              },
              node: a.node,
              fix: (c) => {
                let y = {};
                for (let f of n) {
                  let g = x(s.groups, f);
                  g in y ? y[g] = A(
                    [...y[g], f],
                    s
                  ) : y[g] = [f];
                }
                let h = [];
                for (let f of Object.keys(y).sort())
                  h.push(...A(y[f], s));
                return T(c, n, h, t);
              }
            });
          });
      }
    }
  }
}), re = "sort-exports", Ne = j({
  name: re,
  meta: {
    type: "suggestion",
    docs: {
      description: "enforce sorted exports"
    },
    fixable: "code",
    schema: [
      {
        type: "object",
        properties: {
          type: {
            enum: [
              p.alphabetical,
              p.natural,
              p["line-length"]
            ],
            default: p.alphabetical,
            type: "string"
          },
          order: {
            enum: [d.asc, d.desc],
            default: d.asc,
            type: "string"
          },
          "ignore-case": {
            type: "boolean",
            default: !1
          }
        },
        additionalProperties: !1
      }
    ],
    messages: {
      unexpectedExportsOrder: 'Expected "{{right}}" to come before "{{left}}"'
    }
  },
  defaultOptions: [
    {
      type: p.alphabetical,
      order: d.asc
    }
  ],
  create: (r) => {
    let l = C(r.options.at(0), {
      type: p.alphabetical,
      order: d.asc,
      "ignore-case": !1
    }), s = [[]], t = (u) => {
      u.type === "ExportAllDeclaration" && u.exported === null ? s.push([]) : s.at(-1).push({
        size: v(u.range),
        name: u.source.value,
        node: u
      });
    };
    return {
      ExportAllDeclaration: t,
      ExportNamedDeclaration: (u) => {
        u.source !== null && t(u);
      },
      "Program:exit": () => {
        let u = r.getSourceCode();
        for (let n of s)
          P(n, (e, a) => {
            k(O(e, a, l)) && r.report({
              messageId: "unexpectedExportsOrder",
              data: {
                left: e.name,
                right: a.name
              },
              node: a.node,
              fix: (i) => T(i, n, A(n, l), u)
            });
          });
      }
    };
  }
}), se = "sort-imports", Oe = j({
  name: se,
  meta: {
    type: "suggestion",
    docs: {
      description: "enforce sorted imports"
    },
    fixable: "code",
    schema: [
      {
        id: "sort-imports",
        type: "object",
        properties: {
          "custom-groups": {
            type: "object",
            properties: {
              type: {
                type: "object"
              },
              value: {
                type: "object"
              }
            },
            additionalProperties: !1
          },
          type: {
            enum: [
              p.alphabetical,
              p.natural,
              p["line-length"]
            ],
            default: p.alphabetical,
            type: "string"
          },
          order: {
            enum: [d.asc, d.desc],
            default: d.asc,
            type: "string"
          },
          "ignore-case": {
            type: "boolean",
            default: !1
          },
          groups: {
            type: "array",
            default: []
          },
          "internal-pattern": {
            items: {
              type: "string"
            },
            type: "array"
          },
          "newlines-between": {
            enum: [
              "ignore",
              "always",
              "never"
              /* never */
            ],
            default: "always",
            type: "string"
          },
          "max-line-length": {
            type: "integer",
            minimum: 0,
            exclusiveMinimum: !0
          }
        },
        allOf: [
          { $ref: "#/definitions/max-line-length-requires-line-length-type" }
        ],
        additionalProperties: !1,
        dependencies: {
          "max-line-length": ["type"]
        },
        definitions: {
          "is-line-length": {
            properties: {
              type: { enum: [p["line-length"]], type: "string" }
            },
            required: ["type"],
            type: "object"
          },
          "max-line-length-requires-line-length-type": {
            anyOf: [
              {
                not: { required: ["max-line-length"], type: "object" },
                type: "object"
              },
              { $ref: "#/definitions/is-line-length" }
            ]
          }
        }
      }
    ],
    messages: {
      unexpectedImportsOrder: 'Expected "{{right}}" to come before "{{left}}"',
      missedSpacingBetweenImports: 'Missed spacing between "{{left}}" and "{{right}}" imports',
      extraSpacingBetweenImports: 'Extra spacing between "{{left}}" and "{{right}}" imports'
    }
  },
  defaultOptions: [
    {
      type: p.alphabetical,
      order: d.asc
    }
  ],
  create: (r) => {
    let l = C(r.options.at(0), {
      "newlines-between": "always",
      "custom-groups": { type: {}, value: {} },
      "internal-pattern": ["~/**"],
      type: p.alphabetical,
      order: d.asc,
      "ignore-case": !1,
      groups: []
    }), s = !1;
    for (let o of l.groups)
      if (Array.isArray(o))
        for (let c of o)
          c === "unknown" && (s = !0);
      else
        o === "unknown" && (s = !0);
    s || (l.groups = [...l.groups, "unknown"]);
    let t = r.getSourceCode(), u = [], n = (o) => o.type === "ImportDeclaration" && o.specifiers.length === 0, e = (o) => {
      let c = (S) => [".less", ".scss", ".sass", ".styl", ".pcss", ".css", ".sss"].some(
        (L) => S.endsWith(L)
      ), y = (S) => [
        "./index.d.js",
        "./index.d.ts",
        "./index.js",
        "./index.ts",
        "./index",
        "./",
        "."
      ].includes(S), h = (S) => S.indexOf("..") === 0, f = (S) => S.indexOf("./") === 0, { getGroup: g, defineGroup: m, setCustomGroups: w } = R(l.groups), E = (S) => l["internal-pattern"].length && l["internal-pattern"].some(
        (L) => D(S.source.value, L, {
          nocomment: !0
        })
      ), b = (S) => {
        let L = [
          "bun",
          "bun:ffi",
          "bun:jsc",
          "bun:sqlite",
          "bun:test",
          "bun:wrap",
          "detect-libc",
          "undici",
          "ws"
        ];
        return de.includes(
          S.startsWith("node:") ? S.split("node:")[1] : S
        ) || L.includes(S);
      }, N = (S) => !(S.startsWith(".") || S.startsWith("/"));
      return o.importKind === "type" && (o.type === "ImportDeclaration" && (w(l["custom-groups"].type, o.source.value), y(o.source.value) && m("index-type"), f(o.source.value) && m("sibling-type"), h(o.source.value) && m("parent-type"), E(o) && m("internal-type"), b(o.source.value) && m("builtin-type"), N(o.source.value) && m("external-type")), m("type")), o.type === "ImportDeclaration" && (w(l["custom-groups"].value, o.source.value), n(o) && m("side-effect"), c(o.source.value) && m("style"), y(o.source.value) && m("index"), f(o.source.value) && m("sibling"), h(o.source.value) && m("parent"), E(o) && m("internal"), b(o.source.value) && m("builtin"), N(o.source.value) && m("external")), g();
    }, a = (o) => o.specifiers.length > 1, i = (o) => {
      let c;
      o.type === "ImportDeclaration" ? c = o.source.value : o.moduleReference.type === "TSExternalModuleReference" && o.moduleReference.expression.type === "Literal" ? c = `${o.moduleReference.expression.value}` : c = t.text.slice(...o.moduleReference.range), u.push({
        size: v(o.range),
        group: e(o),
        name: c,
        node: o,
        ...l.type === p["line-length"] && l["max-line-length"] && {
          hasMultipleImportDeclarations: a(
            o
          )
        }
      });
    };
    return {
      TSImportEqualsDeclaration: i,
      ImportDeclaration: i,
      "Program:exit": () => {
        var h;
        let o = (f, g) => !!t.getTokensBetween(
          f.node,
          J(g.node, t) || g.node,
          {
            includeComments: !0
          }
        ).length, c = (f, g) => {
          let m = [], w = {};
          for (let b of g) {
            let N = x(l.groups, b);
            N in w ? w[N] = A(
              [...w[N], b],
              l
            ) : w[N] = [b];
          }
          let E = Object.keys(w).sort().reduce(
            (b, N) => [
              ...b,
              ...w[N]
            ],
            []
          );
          for (let b = 0, N = E.length; b < N; b++) {
            let S = E.at(b);
            if (m.push(
              f.replaceTextRange(
                M(g.at(b).node, t),
                t.text.slice(...M(S.node, t))
              )
            ), l["newlines-between"] !== "ignore") {
              let L = E.at(b + 1);
              if (L) {
                let G = B(
                  t,
                  g.at(b),
                  g.at(b + 1)
                );
                (l["newlines-between"] === "always" && x(l.groups, S) === x(l.groups, L) && G !== 0 || l["newlines-between"] === "never" && G > 0) && m.push(
                  f.removeRange([
                    M(g.at(b).node, t).at(1),
                    M(g.at(b + 1).node, t).at(0) - 1
                  ])
                ), l["newlines-between"] === "always" && x(l.groups, S) !== x(l.groups, L) && G > 1 && m.push(
                  f.replaceTextRange(
                    [
                      M(g.at(b).node, t).at(1),
                      M(g.at(b + 1).node, t).at(
                        0
                      ) - 1
                    ],
                    `
`
                  )
                ), l["newlines-between"] === "always" && x(l.groups, S) !== x(l.groups, L) && G === 0 && m.push(
                  f.insertTextAfterRange(
                    M(g.at(b).node, t),
                    `
`
                  )
                );
              }
            }
          }
          return m;
        }, y = [[]];
        for (let f of u) {
          let g = (h = y.at(-1)) == null ? void 0 : h.at(-1);
          g && o(g, f) ? y.push([f]) : y.at(-1).push(f);
        }
        for (let f of y)
          P(f, (g, m) => {
            let w = x(l.groups, g), E = x(l.groups, m), b = B(t, g, m);
            !(n(g.node) && n(m.node)) && !o(g, m) && (w > E || w === E && k(O(g, m, l))) && r.report({
              messageId: "unexpectedImportsOrder",
              data: {
                left: g.name,
                right: m.name
              },
              node: m.node,
              fix: (N) => c(N, f)
            }), l["newlines-between"] === "never" && b > 0 && r.report({
              messageId: "extraSpacingBetweenImports",
              data: {
                left: g.name,
                right: m.name
              },
              node: m.node,
              fix: (N) => c(N, f)
            }), l["newlines-between"] === "always" && (w < E && b === 0 ? r.report({
              messageId: "missedSpacingBetweenImports",
              data: {
                left: g.name,
                right: m.name
              },
              node: m.node,
              fix: (N) => c(N, f)
            }) : (b > 1 || w === E && b > 0) && r.report({
              messageId: "extraSpacingBetweenImports",
              data: {
                left: g.name,
                right: m.name
              },
              node: m.node,
              fix: (N) => c(N, f)
            }));
          });
      }
    };
  }
}), ae = "sort-objects", Ie = j({
  name: ae,
  meta: {
    type: "suggestion",
    docs: {
      description: "enforce sorted objects"
    },
    fixable: "code",
    schema: [
      {
        type: "object",
        properties: {
          "custom-groups": {
            type: "object"
          },
          "partition-by-comment": {
            type: ["boolean", "string", "array"],
            default: !1
          },
          "partition-by-new-line": {
            type: "boolean",
            default: !1
          },
          "styled-components": {
            type: "boolean",
            default: !0
          },
          type: {
            enum: [
              p.alphabetical,
              p.natural,
              p["line-length"]
            ],
            default: p.alphabetical,
            type: "string"
          },
          order: {
            enum: [d.asc, d.desc],
            default: d.asc,
            type: "string"
          },
          "ignore-case": {
            type: "boolean",
            default: !1
          },
          groups: {
            type: "array"
          }
        },
        additionalProperties: !1
      }
    ],
    messages: {
      unexpectedObjectsOrder: 'Expected "{{right}}" to come before "{{left}}"'
    }
  },
  defaultOptions: [
    {
      type: p.alphabetical,
      order: d.asc
    }
  ],
  create: (r) => {
    let l = (s) => {
      if (s.properties.length > 1) {
        let t = C(r.options.at(0), {
          "partition-by-new-line": !1,
          "partition-by-comment": !1,
          type: p.alphabetical,
          "styled-components": !0,
          "ignore-case": !1,
          order: d.asc,
          "custom-groups": {},
          groups: []
        }), u = (i) => i.type === "Identifier" && i.name === "styled", n = (i) => i !== void 0 && i.type === "CallExpression" && (i.callee.type === "MemberExpression" && u(i.callee.object) || i.callee.type === "CallExpression" && u(i.callee.callee));
        if (!t["styled-components"] && (n(s.parent) || s.parent.type === "ArrowFunctionExpression" && n(s.parent.parent)))
          return;
        let e = r.getSourceCode(), a = (i) => i.reduce(
          (o, c) => {
            var S;
            if (c.type === "SpreadElement" || c.type === "RestElement")
              return o.push([]), o;
            let y = J(c, e), h = (S = o.at(-1)) == null ? void 0 : S.at(-1);
            t["partition-by-comment"] && y && pe(
              t["partition-by-comment"],
              y.value
            ) && o.push([]);
            let f, g = "ignore", m = [], { getGroup: w, setCustomGroups: E } = R(t.groups);
            c.key.type === "Identifier" ? { name: f } = c.key : c.key.type === "Literal" ? f = `${c.key.value}` : f = e.text.slice(...c.key.range);
            let b = {
              size: v(c.range),
              node: c,
              name: f
            };
            t["partition-by-new-line"] && h && B(e, h, b) && o.push([]), c.value.type === "AssignmentPattern" && ((G) => {
              G.right.type === "Identifier" && m.push(G.right.name);
              let ie = ($) => {
                let U = [];
                switch ($.type) {
                  case "ArrowFunctionExpression":
                    U.push($.body);
                    break;
                  case "ConditionalExpression":
                    U.push($.consequent, $.alternate);
                    break;
                  case "LogicalExpression":
                  case "BinaryExpression":
                    U.push($.left, $.right);
                    break;
                  case "CallExpression":
                    U.push(...$.arguments);
                    break;
                }
                U.forEach((z) => {
                  z.type === "Identifier" && m.push(z.name), (z.type === "BinaryExpression" || z.type === "ConditionalExpression") && ie(z);
                });
              };
              switch (G.right.type) {
                case "ArrowFunctionExpression":
                case "ConditionalExpression":
                case "LogicalExpression":
                case "BinaryExpression":
                case "CallExpression":
                  ie(G.right);
                  break;
              }
            })(c.value), E(t["custom-groups"], f);
            let N = {
              ...b,
              group: w(),
              dependencies: m,
              position: g
            };
            return o.at(-1).push(N), o;
          },
          [[]]
        );
        for (let i of a(s.properties))
          P(i, (o, c) => {
            let y = x(t.groups, o), h = x(t.groups, c);
            if (y > h || y === h && k(O(o, c, t))) {
              let f = (g) => {
                let m = {};
                for (let E of i) {
                  let b = x(t.groups, E);
                  b in m ? m[b] = A(
                    [...m[b], E],
                    t
                  ) : m[b] = [E];
                }
                let w = [];
                for (let E of Object.keys(m).sort())
                  w.push(...A(m[E], t));
                return T(g, i, w, e, {
                  partitionComment: t["partition-by-comment"]
                });
              };
              r.report({
                messageId: "unexpectedObjectsOrder",
                data: {
                  left: I(o.name),
                  right: I(c.name)
                },
                node: c.node,
                fix: f
              });
            }
          });
      }
    };
    return {
      ObjectExpression: l,
      ObjectPattern: l
    };
  }
}), ne = "sort-classes", je = j({
  name: ne,
  meta: {
    type: "suggestion",
    docs: {
      description: "enforce sorted classes"
    },
    fixable: "code",
    schema: [
      {
        type: "object",
        properties: {
          type: {
            enum: [
              p.alphabetical,
              p.natural,
              p["line-length"]
            ],
            default: p.alphabetical,
            type: "string"
          },
          "ignore-case": {
            type: "boolean",
            default: !1
          },
          order: {
            enum: [d.asc, d.desc],
            default: d.asc,
            type: "string"
          },
          groups: {
            type: "array",
            default: []
          }
        },
        additionalProperties: !1
      }
    ],
    messages: {
      unexpectedClassesOrder: 'Expected "{{right}}" to come before "{{left}}"'
    }
  },
  defaultOptions: [
    {
      type: p.alphabetical,
      order: d.asc
    }
  ],
  create: (r) => ({
    ClassBody: (l) => {
      if (l.body.length > 1) {
        let s = C(r.options.at(0), {
          type: p.alphabetical,
          order: d.asc,
          "ignore-case": !1,
          groups: ["property", "constructor", "method", "unknown"]
        }), t = r.getSourceCode(), u = l.body.map((n) => {
          var c;
          let e, { getGroup: a, defineGroup: i } = R(s.groups);
          n.type === "StaticBlock" ? e = "static" : n.type === "TSIndexSignature" ? e = t.text.slice(
            n.range.at(0),
            ((c = n.typeAnnotation) == null ? void 0 : c.range.at(0)) ?? n.range.at(1)
          ) : n.key.type === "Identifier" ? { name: e } = n.key : e = t.text.slice(...n.key.range);
          let o = e.startsWith("_") || e.startsWith("#");
          if (n.type === "MethodDefinition") {
            n.kind === "constructor" && i("constructor");
            let y = n.accessibility === "private" || o, h = n.static;
            y && h && i("static-private-method"), y && i("private-method"), h && i("static-method"), n.kind === "get" && i("get-method"), n.kind === "set" && i("set-method"), i("method");
          } else
            n.type === "TSIndexSignature" ? i("index-signature") : n.type === "PropertyDefinition" && ((n.accessibility === "private" || o) && i("private-property"), n.static && i("static-property"), i("property"));
          return {
            size: v(n.range),
            group: a(),
            node: n,
            name: e
          };
        });
        P(u, (n, e) => {
          let a = x(s.groups, n), i = x(s.groups, e);
          n.name !== e.name && (a > i || a === i && k(O(n, e, s))) && r.report({
            messageId: "unexpectedClassesOrder",
            data: {
              left: I(n.name),
              right: I(e.name)
            },
            node: e.node,
            fix: (o) => {
              let c = [], y = u.reduce(
                (f, g) => {
                  let m = x(s.groups, g);
                  return m in f ? f[m] = A(
                    [...f[m], g],
                    s
                  ) : f[m] = [g], f;
                },
                {}
              ), h = Object.keys(y).sort().reduce(
                (f, g) => [
                  ...f,
                  ...y[g]
                ],
                []
              );
              for (let f = 0, g = h.length; f < g; f++)
                c.push(
                  o.replaceTextRange(
                    M(u.at(f).node, t),
                    t.text.slice(
                      ...M(h.at(f).node, t)
                    )
                  )
                );
              return c;
            }
          });
        });
      }
    }
  })
}), oe = "sort-enums", ve = j({
  name: oe,
  meta: {
    type: "suggestion",
    docs: {
      description: "enforce sorted TypeScript enums"
    },
    fixable: "code",
    schema: [
      {
        type: "object",
        properties: {
          type: {
            enum: [
              p.alphabetical,
              p.natural,
              p["line-length"]
            ],
            default: p.alphabetical,
            type: "string"
          },
          "ignore-case": {
            type: "boolean",
            default: !1
          },
          order: {
            enum: [d.asc, d.desc],
            default: d.asc,
            type: "string"
          }
        },
        additionalProperties: !1
      }
    ],
    messages: {
      unexpectedEnumsOrder: 'Expected "{{right}}" to come before "{{left}}"'
    }
  },
  defaultOptions: [
    {
      type: p.alphabetical,
      order: d.asc
    }
  ],
  create: (r) => ({
    TSEnumDeclaration: (l) => {
      if (l.members.length > 1 && l.members.every(({ initializer: s }) => s)) {
        let s = C(r.options.at(0), {
          type: p.alphabetical,
          order: d.asc,
          "ignore-case": !1
        }), t = r.getSourceCode(), u = l.members.map((n) => ({
          name: n.id.type === "Literal" ? `${n.id.value}` : `${t.text.slice(...n.id.range)}`,
          size: v(n.range),
          node: n
        }));
        P(u, (n, e) => {
          k(O(n, e, s)) && r.report({
            messageId: "unexpectedEnumsOrder",
            data: {
              left: I(n.name),
              right: I(e.name)
            },
            node: e.node,
            fix: (a) => T(a, u, A(u, s), t)
          });
        });
      }
    }
  })
}), le = "sort-maps", ke = j({
  name: le,
  meta: {
    type: "suggestion",
    docs: {
      description: "enforce sorted Map elements"
    },
    fixable: "code",
    schema: [
      {
        type: "object",
        properties: {
          type: {
            enum: [
              p.alphabetical,
              p.natural,
              p["line-length"]
            ],
            default: p.alphabetical,
            type: "string"
          },
          order: {
            enum: [d.asc, d.desc],
            default: d.asc,
            type: "string"
          },
          "ignore-case": {
            type: "boolean",
            default: !1
          }
        },
        additionalProperties: !1
      }
    ],
    messages: {
      unexpectedMapElementsOrder: 'Expected "{{right}}" to come before "{{left}}"'
    }
  },
  defaultOptions: [
    {
      type: p.alphabetical,
      order: d.asc
    }
  ],
  create: (r) => ({
    NewExpression: (l) => {
      if (l.callee.type === "Identifier" && l.callee.name === "Map" && l.arguments.length && l.arguments[0].type === "ArrayExpression") {
        let [{ elements: s }] = l.arguments;
        if (s.length > 1) {
          let t = C(r.options.at(0), {
            type: p.alphabetical,
            "ignore-case": !1,
            order: d.asc
          }), u = r.getSourceCode(), n = s.reduce(
            (e, a) => (a === null || a.type === "SpreadElement" ? e.push([]) : e.at(-1).push(a), e),
            [[]]
          );
          for (let e of n) {
            let a = e.map((i) => {
              let o;
              if (i.type === "ArrayExpression") {
                let [c] = i.elements;
                c ? c.type === "Literal" ? o = c.raw : o = u.text.slice(...c.range) : o = `${c}`;
              } else
                o = u.text.slice(...i.range);
              return {
                size: v(i.range),
                node: i,
                name: o
              };
            });
            P(a, (i, o) => {
              k(O(i, o, t)) && r.report({
                messageId: "unexpectedMapElementsOrder",
                data: {
                  left: I(i.name),
                  right: I(o.name)
                },
                node: o.node,
                fix: (c) => T(c, a, A(a, t), u)
              });
            });
          }
        }
      }
    }
  })
}), Ce = "eslint-plugin-perfectionist";
let V = (r) => {
  let l = {
    [se]: [
      "error",
      {
        groups: [
          "type",
          ["builtin", "external"],
          "internal-type",
          "internal",
          ["parent-type", "sibling-type", "index-type"],
          ["parent", "sibling", "index"],
          "object",
          "unknown"
        ],
        "custom-groups": {
          value: {},
          type: {}
        },
        "newlines-between": "always",
        "internal-pattern": ["~/**"]
      }
    ],
    [ne]: [
      "error",
      {
        groups: [
          "index-signature",
          "static-property",
          "private-property",
          "property",
          "constructor",
          "static-method",
          "private-method",
          "method",
          ["get-method", "set-method"],
          "unknown"
        ]
      }
    ],
    [ae]: [
      "error",
      {
        "partition-by-comment": !1
      }
    ],
    [K]: [
      "error",
      {
        "spread-last": !0
      }
    ],
    [X]: ["error"],
    [q]: ["error"],
    [F]: ["error"],
    [H]: ["error"],
    [Q]: ["error"],
    [Y]: ["error"],
    [Z]: ["error"],
    [ee]: ["error"],
    [te]: ["error"],
    [re]: ["error"],
    [oe]: ["error"],
    [le]: ["error"]
  };
  return {
    rules: Object.fromEntries(
      Object.entries(l).map(([s, [t, u = {}]]) => [
        `perfectionist/${s}`,
        [t, Object.assign(u, r)]
      ])
    ),
    plugins: ["perfectionist"]
  };
};
const Re = {
  rules: {
    [K]: me,
    [q]: ye,
    [ne]: je,
    [oe]: ve,
    [re]: Ne,
    [se]: Oe,
    [ee]: we,
    [te]: Ae,
    [le]: ke,
    [H]: be,
    [Q]: xe,
    [Y]: Ee,
    [ae]: Ie,
    [X]: ge,
    [Z]: Se,
    [F]: he
  },
  configs: {
    "recommended-alphabetical": V({
      type: p.alphabetical,
      order: d.asc,
      "ignore-case": !1
    }),
    "recommended-natural": V({
      type: p.natural,
      order: d.asc,
      "ignore-case": !1
    }),
    "recommended-line-length": V({
      type: p["line-length"],
      order: d.desc
    })
  },
  name: Ce
};
export {
  Re as default
};
